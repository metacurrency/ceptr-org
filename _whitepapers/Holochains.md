---
layout: whitepaper
status: Pre-release Draft
title: Holochain
sub-title: Scalable, agent-centric, distributed computing
navigation_weight: 1
slug: holochain
project: holochain
authors:
    "Arthur Brock": artbrock.com
    "Eric Harris-Braun": eric.harris-braun.com
    "Nicolas Luck": "github.com/lucksus"
excerpt: "We present a scalable, evolvable, agent-centric distributed computing platform.  We use a  formalism to characterize distributed systems, show how it applies to some existing distributed systems and demonstrate the benefits of shifting from a data-centric to an agent-centric model. We present the a detailed formal specification of the Holochain system, along with an analysis of its systemic integrity, capacity for evolution, total system computational complexity, implications for use-cases, and current implementation status."
date: '2016-12-05 04:58:14 -0400'
date_gmt: '2016-12-05 04:58:14 -0400'
tags:
- Whitepaper
- Holochain
- Intrinsic Data Integrity
comments: []
---

<!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

* [Introduction](#introduction)
* [Prior Work](#prior-work)
* [Distributed Systems](#distributed-systems)
  * [Formalism](#formalism)
  * [Data-Centric and Agent-Centric Systems](#data-centric-and-agent-centric-systems)
  * [Systemic Evolvability](#systemic-evolvability)
* [Generalized Distributed Computation](#generalized-distributed-computation)
  * [Ethereum](#ethereum)
  * [Holochain](#holochain)
  * [Systemic Integrity Through Validation](#systemic-integrity-through-validation)
  * [Absolute Requirements](#absolute-requirements)
  * [Considered Requirements](#considered-requirements)
  * [Bridging](#bridging)
* [Evolvability](#evolvability)
* [Complexity In Distributed Systems](#complexity-in-distributed-systems)
  * [Bitcoin](#bitcoin)
  * [Ethereum](#ethereum-1)
  * [Blockchain](#blockchain)
  * [Holochain](#holochain-1)
* [Use Cases](#use-cases)
  * [Social Media](#social-media)
  * [Identity](#identity)
  * [Money](#money)
* [Implementation](#implementation)
* [Appendix I: DHThc](#appendix-i-dhtsubhcsub)
* [Appendix II: Fsys](#appendix-ii-fsubsyssub)
* [Acknowledgements](#acknowledgements)
    * [Lumber / Notes](#lumber-notes)
    * [Informal description](#h3-idinformal-descriptioninformal-descriptionh3)
* [Bibliography](#bibliography)

<!-- tocstop -->

# Introduction
<p>Distributed computing platforms have achieved a new level of viability with the advent of two foundational cryptographic tools: secure hashing algorithms, and public-key encryption. These have provided solutions to key problems in distributed computing: verifiable, tamper-proof data for sharing state across nodes in the distributed system, and confirmation of data provenance via digital signature algorithms. The former is achieved by hash-chains, where monotonic data-stores are rendered intrinsically tamper-proof (and thus confidently sharable across nodes) by including hashes of previous entries in subsequent entries. The latter is achieved by combining cryptographic encryption of hashes of data and using the public keys themselves as the addresses of agents, thus allowing other agents in the system to mathematically verify the data‚Äôs source.</p>
<p>Though hash-chains help solve the problem of independently acting agents reliably sharing state, we see two very different approaches in their use which have deep systemic consequences. These approaches are demonstrated by two of today‚Äôs canonical distributed systems:</p>
<ol>
<li><p>git<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>: In git all nodes can update their hash-chains as they see fit. The degree of overlapping shared state of chain entries (known as commit objects) across all nodes is not managed by git but rather explicitly by action of the agent making pull requests and doing merges. We call this approach <span><strong><em>agent-centric</em></strong></span> because of its focus on allowing nodes to share independently evolving data realities.</p></li>
<li><p>Bitcoin<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>: In Bitcoin (and blockchain in general), the ‚Äúproblem&quot; is understood to be that of figuring out how to choose one block of transactions among the many variants being experienced by the mining nodes (as they collect transactions from clients in different orders), and committing that single variant to the single globally shared chain. We call this approach <span><strong><em>data-centric</em></strong></span> because of its focus on creating a single shared data reality among all nodes.</p></li>
</ol>
<p>We claim that this fundamental original stance results directly in the two most significant limitations of the blockchain: scalability and evolvability. These limitations are widely known <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> and many solutions have been offered <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Holochain offers a way forward by directly addressing the root data-centric assumptions of the blockchain approach.</p>
# Prior Work
<p>This paper builds largely on recent work in cryptographic distributed systems and distributed hash tables and multi-agent systems.</p>
<p>Ethereum: Wood <span class="citation"></span>, DHT: <span class="citation"></span> Benet <span class="citation"></span></p>
# Distributed Systems
## Formalism
<p>We define a simple generalized model of a distributed system <span class="math inline"><em>Œ©</em></span> using hash-chains as follows:</p>
<ol>
<li><p>Let <span class="math inline"><em>N</em></span> be the set of elements <span class="math inline">{<em>n</em><sub>1</sub>,‚ÄÜ<em>n</em><sub>2</sub>,‚ÄÜ‚Ä¶<em>n</em><sub><em>n</em></sub>}</span> participating in the system. Call the elements of <span class="math inline"><em>N</em></span> <span><strong><em>nodes</em></strong></span> or <span><strong><em>agents</em></strong></span>.</p></li>
<li><p>Let each node <span class="math inline"><em>n</em></span> consist of a set <span class="math inline"><em>S</em><sub><em>n</em></sub></span> with elements <span class="math inline">{<em>œÉ</em><sub>1</sub>,‚ÄÜ<em>œÉ</em><sub>2</sub>,‚ÄÜ‚Ä¶}</span>. Call the elements of <span class="math inline"><em>S</em><sub><em>n</em></sub></span> the <span><strong><em>state</em></strong></span> of node <span class="math inline"><em>n</em></span>. For the purposes of this paper we assume <span class="math inline">‚àÄ<em>œÉ</em><sub><em>x</em></sub>‚ÄÑ‚àà‚ÄÑ<em>S</em><sub><em>n</em></sub>‚ÄÑ:‚ÄÑ<em>œÉ</em><sub><em>x</em></sub>‚ÄÑ=‚ÄÑ{ùí≥<sub><em>x</em></sub>,‚ÄÜ<em>D</em><sub><em>x</em></sub>}</span> with <span class="math inline">ùí≥<sub><em>x</em></sub></span> being a <span><strong><em>hash-chain</em></strong></span> and <span class="math inline"><em>D</em></span> a set of non-hash chain <span><strong><em>data elements</em></strong></span>.</p></li>
<li><p>Let <span class="math inline"><em>œÑ</em>(<em>œÉ</em><sub><em>i</em></sub>,‚ÄÜ<em>t</em>)=<em>œÉ</em><sub>i+1</sub></span> where <span class="math inline"><em>t</em></span> is arbitrary input which <span class="math inline"><em>œÑ</em></span> transforms to produce <span class="math inline"><em>œÉ</em><sub>i+1</sub></span>. Call <span class="math inline"><em>œÑ</em></span> a <span><strong><em>state transition</em></strong></span> function. Call <span class="math inline"><em>t</em></span> a <span><strong><em>transaction</em></strong></span>.</p></li>
<li><p>Let <span class="math inline"><em>V</em>(<em>t</em>,‚ÄÜ<em>v</em>)</span> be a function that takes <span class="math inline"><em>t</em></span>, along with extra validation data <span class="math inline"><em>v</em></span>, verifies the validity of <span class="math inline"><em>t</em></span> and only if valid calls a transition function for <span class="math inline"><em>t</em></span>. Call <span class="math inline"><em>V</em></span> a <span><strong><em>validation</em></strong></span> function.</p></li>
<li><p>Let <span class="math inline"><em>H</em></span> be a cryptographically secure hash function.</p></li>
<li><p>Let <span class="math inline"><em>œÑ</em><sub>ùí≥</sub>(ùí≥<sub><em>i</em></sub>,‚ÄÜ<em>e</em>)=ùí≥<sub><em>i</em>‚ÄÖ+‚ÄÖ1</sub></span> where <br /><span class="math display">$$\begin{split}
 {\mathcal{X}}_{i+1} &amp;= {\mathcal{X}}_{i} \cup \{x_{i+1}\} \\
  &amp;= \{x_1, \dots, x_i, x_{i+1}\}
\end{split}$$</span><br /> with <br /><span class="math display">$$\begin{split}
x_{i+1} &amp;= \{h,e\} \\
h &amp;= \{ H(e),H(x_a,\dots,x_b)  | a,b\leq i \}
\end{split}$$</span><br /> Call <span class="math inline"><em>h</em></span> a <span><strong><em>header</em></strong></span> and note how the sequence of headers creates a chain (tree, in the general case) by linking each header to the previous header(s) and the entry.</p></li>
<li><p>Let there be functions <span class="math inline"><em>œÑ</em><sub>ùí≥</sub></span> and <span class="math inline"><em>œÑ</em><sub><em>D</em></sub></span> in <span class="math inline"><em>Œ©</em></span> for transforming <span class="math inline"><em>S</em></span></p></li>
<li><p>Let <span class="math inline"><em>I</em><sub><em>n</em></sub>(<em>t</em>)</span> be a function that takes a transaction <span class="math inline"><em>t</em></span>, evaluates it using a function <span class="math inline"><em>V</em><sub><em>x</em></sub></span> appropriate to the transaction type, and if valid uses <span class="math inline"><em>œÑ</em><sub><em>x</em></sub></span> to transform <span class="math inline"><em>S</em></span>. Call <span class="math inline"><em>I</em></span> the <span><strong><em>input</em></strong></span> or <span><strong><em>stimulus</em></strong></span> function.</p></li>
<li><p>Let <span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>x</em>)</span> be a function that can create transactions <span class="math inline"><em>t</em></span> and trigger functions <span class="math inline"><em>V</em><sub><em>x</em></sub></span> and <span class="math inline"><em>œÑ</em><sub><em>x</em></sub></span>, and <span class="math inline"><em>P</em></span> itself is triggered by state changes or the passage of time. Call <span class="math inline"><em>P</em></span> the <span><strong><em>processing</em></strong></span> function.</p></li>
<li><p>Let <span class="math inline"><em>C</em></span> be a channel that allows all nodes in <span class="math inline"><em>N</em></span> to communicate and over which each node has a unique address <span class="math inline"><em>A</em><sub><em>n</em></sub></span>. Call <span class="math inline"><em>C</em></span> and the nodes that communicate on it the <span><strong><em>network</em></strong></span></p></li>
<li><p>Let <span class="math inline"><em>E</em><sub><em>n</em></sub>(<em>i</em>)</span> be a function that changes functions <span class="math inline"><em>V</em>,‚ÄÜ<em>I</em>,‚ÄÜ<em>P</em></span>. Call <span class="math inline"><em>E</em></span> the <span><strong><em>evolution</em></strong></span> function.</p></li>
</ol>
<p>Explanation: this formalism allows us to model separately key aspects of agents.</p>
<p>First we separate the agent‚Äôs state into a cryptographically secured hash-chain part <span class="math inline">ùí≥</span> and another part that holds arbitrary data <span class="math inline"><em>D</em></span>. Then we split the process of updating the state into two steps: 1) the validation of new transactions <span class="math inline"><em>t</em></span> through the validation function <span class="math inline"><em>V</em><sub><em>x</em></sub>(<em>t</em>,‚ÄÜ<em>v</em>)</span>, and 2) the actual change of internal state <span class="math inline"><em>S</em></span> (as either <span class="math inline">ùí≥</span> or <span class="math inline"><em>D</em></span>) through the according state transition function <span class="math inline"><em>œÑ</em><sub><em>x</em></sub></span>. Finally, we distinguish between 1) state transitions triggered by external events, stimuli, received through <span class="math inline"><em>I</em><sub><em>n</em></sub>(<em>t</em>)</span>, and 2) a node‚Äôs internal processing <span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>x</em>)</span> that also results in calling <span class="math inline"><em>V</em><sub><em>X</em></sub></span> and <span class="math inline"><em>œÑ</em><sub><em>x</em></sub></span> with an internally created transaction.</p>
<p>We define some key properties of distributed systems:</p>
<ol>
<li><p>Call a set of nodes in <span class="math inline"><em>N</em></span> for which any of the functions <span class="math inline"><em>T</em>,‚ÄÜ<em>V</em>,‚ÄÜ<em>P</em></span> and <span class="math inline"><em>E</em></span> have the properties of being both reliably known, and known to be identical for that set of nodes: <span><strong><em>trusted</em></strong></span> nodes with respect to the functions so known.</p></li>
<li><p>Call a channel <span class="math inline"><em>C</em></span> with the property that messages in transit can be trusted to arrive exactly as sent: <span><strong><em>secure</em></strong></span>.</p></li>
<li><p>Call a channel <span class="math inline"><em>C</em></span> on which the address <span class="math inline"><em>A</em><sub><em>n</em></sub></span> of a node <span class="math inline"><em>n</em></span> is <span class="math inline"><em>A</em><sub><em>n</em></sub>‚ÄÑ=‚ÄÑ<em>H</em>(<em>p</em><em>k</em><sub><em>n</em></sub>)</span>, where <span class="math inline"><em>p</em><em>k</em><sub><em>n</em></sub></span> is the public key of the node <span class="math inline"><em>n</em></span>, and on which all messages include a digital signature of the message signed by sender: <span><strong><em>authenticated</em></strong></span></p></li>
<li><p>Call a data element that is accessible by its hash <span><strong><em>content addressable</em></strong></span>.</p></li>
</ol>
<p>For the purposes of this paper we assume untrusted nodes, i.e. independently acting agents solely under their own control, and an insecure channel. We do this because the very <em>raison d‚Äô√™tre</em> of the cryptographic tools mentioned above is to allow individual nodes to trust the whole system under this assumption. The cryptography immediately makes visible in the state data when any other node in the system uses a version of the functions different from itself. This property is often referred to as a <span><strong><em>trustless</em></strong></span> system. However, because it simply means that the locus of trust has been shifted to the state data, rather than other nodes, we refer to it as systemic reliance on <span><strong><em>intrinsic data integrity</em></strong></span>. See [sec:integrity] for a detailed discussion on trust in distributed systems.</p>
## Data-Centric and Agent-Centric Systems
<p>Using this definition, Bitcoin can be understood as that system <span><span class="math inline"><em>Œ©</em><sub>bitcoin</sub></span></span>where:</p>
<ol>
<li><p><span class="math inline">$\forall n,m \in N: {\mathcal{X}}_n{\stackrel{!}{=}}{\mathcal{X}}_m$</span></p></li>
<li><p><span class="math inline"><em>V</em><sub><em>n</em></sub>(<em>e</em>,‚ÄÜ<em>v</em>)</span> <span class="math inline"><em>e</em></span> is a block and <span class="math inline"><em>v</em></span> is the output from the ‚Äúproof-of-work&quot; hash-crack algorithm, and <span class="math inline"><em>V</em><sub><em>n</em></sub></span> confirms the validity of <span class="math inline"><em>v</em></span>, the structure and validity of <span class="math inline"><em>e</em></span> according to the double-spend rules<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p></li>
<li><p><span class="math inline"><em>I</em><sub><em>n</em></sub>(<em>t</em>,‚ÄÜ<em>n</em>)</span> accepts transactions from clients and adds them to <span class="math inline"><em>D</em><sub><em>n</em></sub></span> (the <em>mempool</em>) to build a block for later use in triggering <span class="math inline"><em>V</em>()</span></p></li>
<li><p><span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>i</em>)</span> is the <em>mining</em> process including the ‚Äúproof-of-work&quot; algorithm and composes with <span class="math inline"><em>V</em><sub>C</sub>()</span> and <span class="math inline"><em>œÑ</em><sub>C</sub></span> when the hash is cracked.</p></li>
<li><p><span class="math inline"><em>E</em><sub><em>n</em></sub>(<em>i</em>)</span> is not formally defined but can be mapped informally to a decision by humans operating the nodes to install new versions of the Bitcoin software.</p></li>
</ol>
<p>The first point establishes the central aspect of Bitcoin‚Äôs (and blockchain applications‚Äô in general) strategy for solving or avoiding problems otherwise encountered in decentralized systems, and that is by trying to maintain a network state in which all nodes <strong>should</strong> have the same (local) chain.</p>
<p>By contrast, for <span><span class="math inline"><em>Œ©</em><sub>git</sub></span></span>there is no such constraint on any <span class="math inline">ùí≥<sub><em>n</em></sub></span>, <span class="math inline">ùí≥<sub><em>m</em></sub></span> in nodes <span class="math inline"><em>n</em></span> and <span class="math inline"><em>m</em></span> matching, also <span class="math inline"><em>V</em><sub>C</sub>(<em>e</em>,‚ÄÜ<em>v</em>)</span> only checks the structural validity of <span class="math inline"><em>e</em></span> as a commit object not it‚Äôs content, and <span class="math inline"><em>I</em><sub><em>n</em></sub>(<em>t</em>)</span> can be understood to be the set git commands available to the user, and <span class="math inline"><em>œÑ</em><sub>C</sub></span> the function that adds a commit object and <span class="math inline"><em>œÑ</em><sub>D</sub></span> the function that adds code to the <code>index</code> triggered by <code>add</code>. <span class="math inline"><em>E</em></span> is, similarly to <span><span class="math inline"><em>Œ©</em><sub>bitcoin</sub></span></span>, not formally defined for <span><span class="math inline"><em>Œ©</em><sub>git</sub></span></span>.</p>
<p>Our model of a distributed system makes one thing very clear about the difference between <span><span class="math inline"><em>Œ©</em><sub>bitcoin</sub></span></span>and <span><span class="math inline"><em>Œ©</em><sub>git</sub></span></span>. As the size of <span class="math inline">ùí≥<sub><em>n</em></sub></span> grows, necessarily all nodes of <span><span class="math inline"><em>Œ©</em><sub>bitcoin</sub></span></span>must grow in size, whereas this is not necessarily the case for <span><span class="math inline"><em>Œ©</em><sub>git</sub></span></span>. Though this seems like a clear limitation, it comes as a direct consequence of the constraint of <span class="math inline">$\forall n,m \in N: {\mathcal{X}}_n{\stackrel{!}{=}}{\mathcal{X}}_m$</span>. Interestingly this is actually considered Bitcoin‚Äôs strength as it defines the heart of ‚Äúconsensus&quot; in the blockchain world, i.e. a limitation and method to the achieve sameness of state of all nodes.</p>
<p>It‚Äôs not surprising that a data-centric approach was used for Bitcoin. This comes from the fact that its stated intent was to create digitally transferable ‚Äúcoins&quot;, i.e. to model in a distributed digital system that property of matter known as location. On centralized computer systems this doesn‚Äôt even appear as a problem, because centralized systems have been designed to allow us to think from a data-centric perspective. They allow us to believe in a kind of data objectivity, as if data exists, like a physical object sitting someplace having a location. They allow us to think in terms of an absolute frame - as if there <em>is</em> a correct truth about data and/or time sequence, and suggests that ‚Äúconsensus&quot; should converge on this truth. In fact, this is not a property of information. Data exists always from the vantage point of an observer. It is this fact that makes digitally transferable ‚Äúcoins&quot; a hard problem in distributed systems where there is always more than one vantage point.</p>
<p>In the distributed world events don‚Äôt happen in the same sequence for all observers. For Blockchain specifically this is the heart of the matter: choosing which block from all the nodes receiving transactions in different orders, to use for the the ‚Äúconsensus,&quot; i.e. what single vantage point for enforce on all nodes. Blockchains don‚Äôt record a universal ordering of events ‚Äì they manufacture a single authoritative ordering of events, by stringing together a tiny fragment of local vantage points into one global record that has passed validation rules.</p>
<p>The use of the word consensus seems at best dubious as a description of a systemic requirement that all nodes carry identical values of <span class="math inline">ùí≥<sub><em>n</em></sub></span>. Especially when the algorithm for ensuring that sameness is essentially a digital lottery powered by expensive computation that‚Äôs primary design feature is to randomize which node gets to run <span class="math inline"><em>V</em><sub><em>n</em></sub></span> such that no node has preference to which <span class="math inline"><em>e</em></span> gets added to <span class="math inline">ùí≥<sub><em>n</em></sub></span>.</p>
<p>Consensus as normally used implies deliberation with regard to differences and work on crafting a perspective that holds for all parties, rather than simply selecting one party‚Äôs dataset at random.</p>
<p>A more accurate term for the algorithm would be ‚Äúproof-of-luck&quot; and for the process itself simply sameness, not consensus. If you start from a data-centric view point, which naturally throws out the ‚Äúexperience&quot; of all agents in favor of just one, it‚Äôs much harder to design them to engage in processes that actually have the real-world properties of consensus. If the constraint of keeping all nodes‚Äô states the same were adopted consciously as a fit for a specific purpose, this would not be particularly problematic. Unfortunately the legacy of this data-centric view point has been held mostly unconsciously and is adopted by more generalized distributed computing systems, for which the intent doesn‚Äôt specifically include the need to model ‚Äúdigital matter&quot; with universally absolute location. While having the advantages of simplicity it also immediately transfers to them the scalability issues, but worse, it makes it hard to take advantages inherent in agent-centric approach.</p>
## Systemic Evolvability
<p>Neither of the systems discussed so far address the question of evolvability directly in-system. The evolution function <span class="math inline"><em>E</em></span> is not formalized and left to humans operating the nodes. This has the very interesting side-effect of, in practice, obviating the very decentralization aimed for by the design of these systems and relegating it squarely back in traditional practices <span class="citation"></span>. For truly successful distributed systems, this cannot be left out of the system. We discuss evolvability more fully in Section¬†[sec:evo]</p>
# Generalized Distributed Computation
<p>The previous section described a general formalism for distributed systems, and compared git to Bitcoin as an example of an agent-centric vs. a data-centric distributed system. Neither of these systems, however provides generalized computation in the sense of being a framework for writing computer programs or creating applications. So, lets add the following constraints to formalism¬†[sec:formalism] as follows:</p>
<ol>
<li><p>With respect to a machine <span class="math inline"><em>M</em></span> some values of <span class="math inline"><em>S</em><sub><em>n</em></sub></span> can be interpreted as: executable code, and the results of code execution, and may be accessible to <span class="math inline"><em>M</em></span> and the code. Call such values the <span><strong><em>machine state</em></strong></span>.</p></li>
<li><p><span class="math inline">‚àÉ<em>t</em></span> and nodes <span class="math inline"><em>n</em></span> such that <span class="math inline"><em>I</em><sub><em>n</em></sub>(<em>t</em>)</span> will trigger execution of that code. Call such transaction values <span><strong><em>calls</em></strong></span>.</p></li>
</ol>
## Ethereum
<p>Ethereum<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> provides the current premier example of generalized distributed computing using the blockchain model. It lives up to the constraints listed above as described by Wood <span class="citation"></span> where the bulk of the paper can be understood as a specification of a validation function <span class="math inline"><em>V</em><sub><em>n</em></sub>()</span> and the described state transition function <span class="math inline"><em>œÉ</em><sub>t+1</sub>‚ÄÑ‚â°‚ÄÑ<em>Œ•</em>(<em>œÉ</em>,‚ÄÜ<em>T</em>)</span> as a specification of how constraints above are met. Unfortunately the data-centric legacy inherent in Ethereum is immediately observable in its high compute cost<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> and difficulty in scaling<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
## Holochain
<p>We now proceed to describe an agent-centric distributed generalized computing system, where nodes can still confidently participate in the system as whole even though they are not constrained to maintaining the same chain state as all other nodes.</p>
<p>In broad strokes: A Holochain is a unique source chain for every agent, paired with a validating, monotonic, sharded, distributed hash table (DHT) where every node enforces validation rules on data in the DHT as well as verifying provenance of data from the source chains where it originated.</p>
<p>Using our formalism, a Holochain based application <span><span class="math inline"><em>Œ©</em><sub>hc</sub></span></span>is defined as:</p>
<ol>
<li><p>Call <span class="math inline">ùí≥<sub><em>n</em></sub></span> the <span><strong><em>source chain</em></strong></span> of <span class="math inline"><em>n</em></span>.</p></li>
<li><p>Let <span class="math inline"><em>M</em></span> be a virtual machine used to execute code.</p></li>
<li><p>Let the initial entry of all <span class="math inline">ùí≥<sub><em>n</em></sub></span> in <span class="math inline"><em>N</em></span> be identical and consist in the set <span><span class="math inline">DNA</span></span><span class="math inline">{<em>e</em><sub>1</sub>,‚ÄÜ<em>e</em><sub>2</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>f</em><sub>1</sub>,‚ÄÜ<em>f</em><sub>2</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>p</em><sub>1</sub>,‚ÄÜ<em>p</em><sub>2</sub>,‚ÄÜ‚Ä¶}</span> where <span class="math inline"><em>e</em><sub><em>x</em></sub></span> are definitions of entry types that can be added to the chain, <span class="math inline"><em>f</em><sub><em>x</em></sub></span> are functions defined as executable on <span class="math inline"><em>M</em></span> (which we also refer to as the set <span class="math inline"><em>F</em><sub><em>a</em><em>p</em><em>p</em></sub>‚ÄÑ=‚ÄÑ{<em>a</em><em>p</em><em>p</em><sub>1</sub>,‚ÄÜ<em>a</em><em>p</em><em>p</em><sub>2</sub>,‚ÄÜ‚Ä¶}</span>) and <span class="math inline"><em>p</em><sub><em>x</em></sub></span> are various system properties .</p></li>
<li><p>Let <span class="math inline"><em>Œπ</em><sub><em>n</em></sub></span> be the second entry of all <span class="math inline">ùí≥<sub><em>n</em></sub></span> and be set of the form <span class="math inline">{<em>p</em>,‚ÄÜ<em>i</em>}</span> where <span class="math inline"><em>p</em></span> is the public key, and <span class="math inline"><em>i</em></span> is identifying information appropriate to the use of this particular <span><span class="math inline"><em>Œ©</em><sub>hc</sub></span></span>. Note that though this entry is of the same format for all <span class="math inline">ùí≥<sub><em>n</em></sub></span> it‚Äôs content is not the same. Call this entry the <span><strong><em>agent identity</em></strong></span> entry.</p></li>
<li><p><span class="math inline">‚àÄ<em>e</em><sub><em>x</em></sub>‚ÄÑ‚àà‚ÄÑ<em>D</em><em>N</em><em>A</em></span> let there be an <span class="math inline"><em>a</em><em>p</em><em>p</em><sub><em>x</em></sub>‚ÄÑ‚àà‚ÄÑ<em>F</em><sub><em>a</em><em>p</em><em>p</em></sub></span> which can be used to validate transactions that involve entries of type <span class="math inline"><em>e</em><sub><em>x</em></sub></span>. Call this set <span class="math inline"><em>F</em><sub><em>v</em></sub></span> or the <span><strong><em>application validation functions</em></strong></span>.</p></li>
<li><p>Let there be a function <span class="math inline"><em>V</em><sub><em>s</em><em>y</em><em>s</em></sub>(<em>e</em><em>x</em>,‚ÄÜ<em>e</em>,‚ÄÜ<em>v</em>)</span> which checks that <span class="math inline"><em>e</em></span> is of the form specified by the entry definition for <span class="math inline"><em>e</em><sub><em>x</em></sub>‚àà</span> <span><span class="math inline">DNA</span></span>. Call this function the <span><strong><em>system entry validation function</em></strong></span></p></li>
<li><p>Let the overall validation function <span class="math inline"><em>V</em>(<em>e</em>,‚ÄÜ<em>v</em>)‚â°‚ãÅ<sub><em>x</em></sub><em>F</em><sub><em>v</em></sub>(<em>e</em><sub><em>x</em></sub>)(<em>v</em>)‚àß<em>V</em><sub><em>s</em><em>y</em><em>s</em></sub>(<em>e</em><sub><em>x</em></sub>,‚ÄÜ<em>e</em>,‚ÄÜ<em>v</em>)</span>.</p></li>
<li><p>Let <span class="math inline"><em>F</em><sub><em>I</em></sub></span> be a subset of <span class="math inline"><em>F</em><sub><em>a</em><em>p</em><em>p</em></sub></span> distinct from <span class="math inline"><em>F</em><sub><em>v</em></sub></span> such that <span class="math inline">‚àÄ<em>f</em><sub><em>x</em></sub>(<em>t</em>)‚àà<em>F</em><sub><em>I</em></sub></span> there exists a <span class="math inline"><em>t</em></span> to <span class="math inline"><em>I</em>(<em>t</em>)</span> that will trigger <span class="math inline"><em>f</em><sub><em>x</em></sub>(<em>t</em>)</span>. Call the functions in <span class="math inline"><em>F</em><sub><em>I</em></sub></span> the <span><strong><em>exposed functions</em></strong></span>.</p></li>
<li><p>Call any functions in <span class="math inline"><em>F</em><sub><em>a</em><em>p</em><em>p</em></sub></span> not in <span class="math inline"><em>F</em><sub><em>v</em></sub></span> or <span class="math inline"><em>F</em><sub><em>I</em></sub></span> <span><strong><em>internal functions</em></strong></span> and allow them to be called by other functions.</p></li>
<li><p>Let the channel <span class="math inline"><em>C</em></span> be <span><strong><em>authenticated</em></strong></span></p></li>
<li><p>Let <span class="math inline"><em>D</em><em>H</em><em>T</em></span> define a distributed hash table on an authenticated channel as follows:</p>
<ol>
<li><p>Let <span class="math inline"><em>Œî</em></span> be a set <span class="math inline">{<em>Œ¥</em><sub>1</sub>,‚ÄÜ<em>Œ¥</em><sub>2</sub>,‚ÄÜ‚Ä¶}</span> where <span class="math inline"><em>Œ¥</em><sub><em>x</em></sub></span> is a set <span class="math inline">{<em>k</em><em>e</em><em>y</em>,‚ÄÜ<em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>}</span> where <span class="math inline"><em>k</em><em>e</em><em>y</em></span> is always the hash <span class="math inline"><em>H</em>(<em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>)</span> of <span class="math inline"><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></span>. Call <span class="math inline"><em>Œî</em></span> the <span><strong><em>DHT state</em></strong></span>.</p></li>
<li><p>Let <span class="math inline"><em>F</em><sub><em>D</em><em>H</em><em>T</em></sub></span> be the set of functions <span class="math inline">{<em>d</em><em>h</em><em>t</em><sub>put</sub>,‚ÄÜ<em>d</em><em>h</em><em>t</em><sub>get</sub>}</span> where:</p>
<ol>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>put</sub>(<em>Œ¥</em><sub>key,value</sub>)</span> adds <span class="math inline"><em>Œ¥</em><sub>key,value</sub></span> to <span class="math inline"><em>Œî</em></span></p></li>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>get</sub>(<em>k</em><em>e</em><em>y</em>)=<em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></span> of <span class="math inline"><em>Œ¥</em><sub>key,value</sub></span> in <span class="math inline"><em>Œî</em></span></p></li>
</ol></li>
<li><p>[routable] Assume <span class="math inline"><em>x</em>,‚ÄÜ<em>y</em>‚ÄÑ‚àà‚ÄÑ<em>N</em></span> and <span class="math inline"><em>Œ¥</em><sub><em>i</em></sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em><sub><em>x</em></sub></span> but <span class="math inline"><em>Œ¥</em><sub><em>i</em></sub>‚ÄÑ‚àâ‚ÄÑ<em>Œî</em><sub><em>y</em></sub></span>. Allow that when <span class="math inline"><em>y</em></span> calls <span class="math inline"><em>d</em><em>h</em><em>t</em><sub>get</sub>(<em>k</em><em>e</em><em>y</em>)</span> <span class="math inline"><em>Œ¥</em><sub><em>i</em></sub></span> will be retrieved from <span class="math inline"><em>x</em></span> over channel <span class="math inline"><em>X</em></span> and added to <span class="math inline"><em>Œî</em><sub><em>y</em></sub></span>.</p></li>
</ol>
<p>DHT are sufficiently mature that there are a number of ways to ensure property [routable]. For our implementation we use <span class="citation"></span>.</p></li>
<li><p>Let <span class="math inline"><em>D</em><em>H</em><em>T</em><sub>hc</sub></span> augment <span class="math inline"><em>D</em><em>H</em><em>T</em></span> as follows:</p>
<ol>
<li><p>Let <span class="math inline"><em>q</em></span> and <span class="math inline"><em>r</em></span> be parameters of <span class="math inline"><em>D</em><em>H</em><em>T</em><sub>hc</sub></span> that are to be set dependent on the characteristics deemed beneficial for the given application. Call <span class="math inline"><em>q</em></span> the <span><strong><em>neighborhood size</em></strong></span> and <span class="math inline"><em>r</em></span> the <span><strong><em>redundancy factor</em></strong></span>.</p></li>
<li><p><span class="math inline">‚àÄ<em>Œ¥</em><sub>key,value</sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em></span> constrain <span class="math inline"><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></span> to be an entry type as defined in <span><span class="math inline">DNA</span></span>. We do this by ensuring that any function call <span class="math inline"><em>d</em><em>h</em><em>t</em><sub><em>x</em></sub>(<em>y</em>)</span> which would modify <span class="math inline"><em>Œî</em></span> does so <span class="math inline">‚áî</span> <span class="math inline"><em>F</em><sub><em>v</em></sub>(<em>y</em>)</span> indicates that <span class="math inline"><em>y</em></span> is valid.</p></li>
<li><p>Enforce that all elements of <span class="math inline"><em>Œî</em></span> only be changed monotonically, that is, elements <span class="math inline"><em>Œ¥</em></span> can only be added to <span class="math inline"><em>Œî</em></span> not removed.</p></li>
<li><p>Include in <span class="math inline"><em>F</em><sub><em>D</em><em>H</em><em>T</em></sub></span> the functions defined in [sec:apdx1]</p></li>
<li><p>Allow the sets <span class="math inline"><em>Œ¥</em>‚ÄÑ‚àà‚ÄÑ<em>Œî</em></span> to also include more elements as defined in [sec:apdx1]</p></li>
<li><p>Let <span class="math inline"><em>d</em>(<em>x</em>,‚ÄÜ<em>y</em>)</span> be a <em>symmetric</em> and <em>unidirectional</em> distance metric within the hash space defined by <span class="math inline"><em>H</em></span>, as for example the XOR metric defined in <span class="citation"></span>. Note that this metric can be applied between entries and nodes alike since the addresses of both are values of the same hash function <span class="math inline"><em>H</em></span> (i.e. <span class="math inline"><em>Œ¥</em><sub><em>k</em><em>e</em><em>y</em></sub>‚ÄÑ=‚ÄÑ<em>H</em>(<em>Œ¥</em><sub><em>v</em><em>a</em><em>l</em><em>u</em><em>e</em></sub>)</span> and <span class="math inline"><em>A</em><sub><em>n</em></sub>‚ÄÑ=‚ÄÑ<em>H</em>(<em>p</em><em>k</em><sub><em>n</em></sub>)</span>).</p></li>
<li><p>Let <span class="math inline"><em>ŒΩ</em>(<em>A</em><sub><em>n</em></sub>,‚ÄÜ<em>q</em>)=<em>œà</em><sub><em>n</em></sub></span> be the set of <span class="math inline"><em>q</em></span> nodes <span class="math inline">{<em>n</em><sub>1</sub>,‚ÄÜ<em>n</em><sub>2</sub>,‚ÄÜ‚Ä¶,‚ÄÜ<em>n</em><sub><em>q</em></sub>}</span> closest to <span class="math inline"><em>n</em></span>, so that <span class="math inline">‚àÄ<em>n</em><sub><em>i</em></sub>‚ÄÑ‚àà‚ÄÑ<em>œà</em><sub><em>n</em></sub>,‚ÄÜ<em>n</em><sub>0</sub>‚ÄÑ‚àâ‚ÄÑ<em>œà</em><sub><em>n</em></sub>:</span> <br /><span class="math display">$$\begin{split}
d(A_n,A_{n_0})&amp; &gt; d(A_n,A_{n_i})\\
\wedge \left\vert\psi_n\right\vert &amp;= q.
\end{split}$$</span><br /></p>
<p>Call <span class="math inline"><em>œà</em><sub><em>n</em></sub></span> a <span><strong><em>neighborhood</em></strong></span> of size <span class="math inline"><em>q</em></span> in <span class="math inline"><em>N</em></span> around <span class="math inline"><em>n</em></span>. Enforce that nodes maintain a reasonable up-to date representation of their neighborhood (of application specific size <span class="math inline"><em>q</em></span>) as peers appear and disappear from the network.</p></li>
<li><p>Enforce that every node <span class="math inline"><em>n</em></span> shares its elements in <span class="math inline"><em>Œî</em><sub><em>n</em></sub></span> with all nodes in its neighborhood <span class="math inline"><em>œà</em><sub><em>n</em></sub></span>. Call this sharing <span><strong><em>gossip</em></strong></span>.</p></li>
<li><p>Allow every node <span class="math inline"><em>n</em></span> to discard every <span class="math inline"><em>Œ¥</em><sub><em>x</em></sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em><sub><em>n</em></sub></span> if the number of closer (with regards to <span class="math inline"><em>d</em>(<em>x</em>,‚ÄÜ<em>y</em>)</span>) nodes <br /><span class="math display"><em>œÅ</em><sub><em>x</em></sub>‚ÄÑ=‚ÄÑ|{<em>n</em><sub><em>i</em></sub>|<em>d</em>(<em>A</em><sub><em>n</em><sub><em>i</em></sub></sub>,<em>Œ¥</em><sub><em>x</em>,‚ÄÜ<em>k</em><em>e</em><em>y</em></sub>)&lt;<em>d</em>(<em>A</em><sub><em>n</em></sub>,<em>Œ¥</em><sub><em>x</em>,‚ÄÜ<em>k</em><em>e</em><em>y</em></sub>}|</span><br /> is greater than the <span><strong><em>redundancy factor</em></strong></span> <span class="math inline"><em>r</em></span>. Note that this results in the network adapting to changes in topology and DHT state migrations by regulating the number of network-wide redundant copies of all <span class="math inline"><em>Œ¥</em><sub><em>i</em></sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em></span> to match <span class="math inline"><em>r</em></span>. This implies the existence of <span class="math inline"><em>r</em></span> partitions of N called <span><strong><em>shards</em></strong></span> that each (among all their nodes <span class="math inline"><em>N</em><sub><em>S</em><em>h</em><em>a</em><em>r</em><em>d</em><sub><em>i</em></sub></sub>‚ÄÑ‚äÇ‚ÄÑ<em>N</em></span>) hold a complete redundant copy of <span class="math inline"><em>Œî</em></span> : <br /><span class="math display">$$\bigcup\limits_{n\in N_{Shard_i}} {\Delta}_n = {\Delta}.$$</span><br /></p></li>
</ol>
<p>Call <span class="math inline"><em>D</em><em>H</em><em>T</em><sub>hc</sub></span> a <span><strong><em>validating</em></strong></span>, <span><strong><em>monotonic</em></strong></span>, <span><strong><em>sharded</em></strong></span> DHT.</p></li>
<li><p><span class="math inline">‚àÄ<em>n</em>‚ÄÑ‚àà‚ÄÑ<em>N</em></span> assume <span class="math inline"><em>n</em></span> implements <span class="math inline"><em>D</em><em>H</em><em>T</em><sub>hc</sub></span>, that is: <span class="math inline"><em>Œî</em></span> is a subset of <span class="math inline"><em>D</em></span> (the non hash-chain state data), and <span class="math inline"><em>F</em><sub><em>D</em><em>H</em><em>T</em></sub></span> are available to <span class="math inline"><em>n</em></span>, though note that these functions are NOT directly available to the functions <span class="math inline"><em>F</em><sub><em>a</em><em>p</em><em>p</em></sub></span> defined in <span><span class="math inline">DNA</span></span>.</p></li>
<li><p>Let <span class="math inline"><em>F</em><sub><em>s</em><em>y</em><em>s</em></sub></span> be the set of functions <span class="math inline">{<em>s</em><em>y</em><em>s</em><sub>commit</sub>,‚ÄÜ<em>s</em><em>y</em><em>s</em><sub>get</sub>,‚ÄÜ‚Ä¶}</span> where:</p>
<ol>
<li><p><span class="math inline"><em>s</em><em>y</em><em>s</em><sub>commit</sub>(<em>e</em>)</span> uses the system validation function <span class="math inline"><em>V</em>(<em>e</em>,‚ÄÜ<em>v</em>)</span> to add <span class="math inline"><em>e</em></span> to <span class="math inline">ùí≥</span>, and if successful calls <span class="math inline"><em>d</em><em>h</em><em>t</em><sub>put</sub>(<em>H</em>(<em>e</em>),<em>e</em>)</span>.</p></li>
<li><p><span class="math inline"><em>s</em><em>y</em><em>s</em><sub>get</sub>(<em>k</em>)=<em>d</em><em>h</em><em>t</em><sub>get</sub>(<em>k</em>)</span></p></li>
<li><p><span class="math inline">‚Ä¶</span> functions defined in [sec:apdx2]</p></li>
</ol></li>
<li><p>Allow the functions in <span class="math inline"><em>F</em><sub><em>a</em><em>p</em><em>p</em></sub></span> defined in the <span><span class="math inline">DNA</span></span>¬†to call the functions in <span class="math inline"><em>F</em><sub><em>s</em><em>y</em><em>s</em></sub></span>.</p></li>
<li><p>Let <span class="math inline"><em>m</em></span> be an arbitrary message. Include in <span class="math inline"><em>F</em><sub><em>s</em><em>y</em><em>s</em></sub></span> the function <span class="math inline"><em>s</em><em>y</em><em>s</em><sub>send</sub>(<em>A</em><sub>to</sub>,‚ÄÜ<em>m</em>)</span> which when called on <span class="math inline"><em>n</em><sub>from</sub></span> will trigger the function <span class="math inline"><em>a</em><em>p</em><em>p</em><sub>receive</sub>(<em>A</em><sub>from</sub>,‚ÄÜ<em>m</em>)</span> in the <span><span class="math inline">DNA</span></span>¬†on the node <span class="math inline"><em>n</em><sub>to</sub></span>. Call this mechanism <span><strong><em>node-to-node messaging</em></strong></span>.</p></li>
<li><p>[private] Allow that the definition of entries in <span><span class="math inline">DNA</span></span>¬†can mark entry types as <span><strong><em>private</em></strong></span>. Enforce that if an entry <span class="math inline"><em>œÉ</em><sub><em>x</em></sub></span> is of such a type then <span class="math inline"><em>œÉ</em><sub><em>x</em></sub>‚ÄÑ‚àâ‚ÄÑ<em>Œî</em></span>. Note however that entries of such type can be sent as node-to-node messages.</p></li>
<li><p>Let the system processing function <span class="math inline"><em>P</em>(<em>i</em>)</span></p></li>
</ol>
## Systemic Integrity Through Validation
<p>The appeal of the data-centric approach to distributed computing comes from the fact that if you can prove that all nodes reliably have the same data then that provides strong general basis from which to prove the integrity of the system as a whole. In the case of Bitcoin, the <span class="math inline">ùí≥</span> holds the transactions and the unspent transaction outputs which allows nodes to verify future transactions against double-spend. In the case of Ethereum, <span class="math inline">ùí≥</span> holds essentially pointers to machine state . Proving the consistency across all nodes of those data sets is fundamental to the integrity of those systems.</p>
<p>However, because we have started with the assumption (see [sec:formalism]) of distributed systems of independently acting agents, any <em>proof</em> of <span class="math inline">$\forall n,m \in N: {\mathcal{X}}_n{\stackrel{!}{=}}{\mathcal{X}}_m$</span> in blockchain based system is better understood as a <em>choice</em> (hence our use of the <span class="math inline">${\stackrel{!}{=}}$</span>), in that nodes use their agency to decide when to stop interacting with other nodes based on detecting that the <span class="math inline">ùí≥</span> state no longer matches. This might also be called ‚Äúproof by enforcement,&quot; and is also appropriately known as a <span><strong><em>fork</em></strong></span> because essentially it results in partitioning of the network.</p>
<p>The heart of the matter has to do with the trust any single agent has is in the system. In <span class="citation"></span> Section 1.1 (Driving Factors) we read:</p>
<blockquote>
<p>Overall, I wish to provide a system such that users can be guaranteed that no matter with which other individuals, systems or organisations they interact, they can do so with absolute confidence in the possible outcomes and how those outcomes might come about.</p>
</blockquote>
<p>The idea of ‚Äúabsolute confidence&quot; here seems important, and we attempt to understand it more formally and generally for distributed systems.</p>
<ol>
<li><p>Let <span class="math inline"><em>Œ®</em><sub><em>Œ±</em></sub></span> be a measure of the confidence an agent has in various aspects of the system it participates in, where <span class="math inline">0‚ÄÑ‚â§‚ÄÑ<em>Œ®</em>‚ÄÑ‚â§‚ÄÑ1</span> and 0 represents no confidence and 1 represents absolute confidence.</p></li>
<li><p>Let <span class="math inline"><em>R</em><sub><em>n</em></sub>‚ÄÑ=‚ÄÑ{<em>Œ±</em><sub>1</sub>,‚ÄÜ<em>Œ±</em><sub>2</sub>,‚ÄÜ...‚Ä¶}</span> define a set of aspects about the system with which an agent <span class="math inline"><em>n</em>‚ÄÑ‚àà‚ÄÑ<em>N</em></span> measures confidence. Call <span class="math inline"><em>R</em><sub><em>n</em></sub></span> the <span><strong><em>requirements</em></strong></span> of <span class="math inline"><em>n</em></span> with respect to <span class="math inline"><em>Œ©</em></span>.</p></li>
<li><p>Let <span class="math inline"><em>Œµ</em><sub><em>n</em></sub>(<em>Œ±</em>)</span> be a thresholding function for node <span class="math inline"><em>n</em>‚ÄÑ‚àà‚ÄÑ<em>N</em></span> with respect to <span class="math inline"><em>Œ±</em></span> such that when <span class="math inline"><em>Œ®</em><sub><em>Œ±</em></sub>‚ÄÑ&lt;‚ÄÑ<em>Œµ</em>(<em>Œ±</em>)</span> then <span class="math inline"><em>n</em></span> will either stop participating in the system, or reject the participation of others (resulting in a fork).</p></li>
<li><p>Let <span class="math inline"><em>R</em><sub><em>A</em></sub></span> and Let <span class="math inline"><em>R</em><sub><em>C</em></sub></span> be partitions of <span class="math inline"><em>R</em></span> where <br /><span class="math display">$$\begin{split}
\forall \alpha \in R_A:\varepsilon(\alpha)=1\\
\forall \alpha \in R_C:\varepsilon(\alpha)&lt;1
\end{split}$$</span><br /> so any value of <span class="math inline"><em>Œ®</em>‚ÄÑ‚â†‚ÄÑ1</span> is rejected in <span class="math inline"><em>R</em><sub><em>A</em></sub></span> and any value <span class="math inline"><em>Œ®</em>‚ÄÑ&lt;‚ÄÑ<em>Œµ</em>(<em>Œ±</em>)</span> is rejected in <span class="math inline"><em>R</em><sub><em>C</em></sub></span>. Call <span class="math inline"><em>R</em><sub><em>A</em></sub></span> the <span><strong><em>absolute requirements</em></strong></span> and <span class="math inline"><em>R</em><sub><em>C</em></sub></span> the <span><strong><em>considered requirements</em></strong></span>.</p></li>
</ol>
<p>It makes sense to allow for both <span class="math inline"><em>R</em><sub><em>C</em></sub></span> and <span class="math inline"><em>R</em><sub><em>A</em></sub></span> in multi-agent systems depending on context, where the context indicates the value of how much work it takes to establish a particular level of confidence with respect to the consequences involved. For example two contexts for transactions:</p>
<ol>
<li><p>delivery of an email message and we are trying to validate it as spam or not</p></li>
<li><p>commit of monetary transaction where we are trying to validate it against double-spend</p></li>
</ol>
<p>These contexts have different consequences that an agent may wish to evaluate differently and may be willing to attach more or less resources to in validating. One of the key design elements of Holochain was to allow such validation functions to be set contextually per application, and expose these contexts explicitly.</p>
## Absolute Requirements
<ol>
<li><p>Intrinsic Data Integrity</p></li>
<li><p>CALM &amp; Logical Monotonicity</p></li>
<li><p>Provenance</p></li>
<li><p>...</p></li>
</ol>
## Considered Requirements
<p>Tools in Holochain available to app developers for use in Considered Requirements, some of which are also used at the system level an globally parameterized for an application.</p>
<ol>
<li><p>Countersigning</p></li>
<li><p>Notaries</p></li>
<li><p>Publish Headers</p></li>
<li><p>Source-chain examination.</p></li>
<li><p>Blocked-lists.</p></li>
<li><p>...</p></li>
</ol>
## Bridging
# Evolvability
# Complexity In Distributed Systems
<p>In this section we discuss the complexity of our proposed architecture for decentralised systems and compare it to the increasingly adopted Blockchain pattern.</p>
<p>Formally describing the complexity of decentralized multi-agent systems is a non-trivial task for which more complex approaches have been suggested (<span class="citation"></span>). This might be the reason why there happens to be unclarity and misunderstandings within communities discussing complexity and scalability of Bitcoin for example <span><span class="citation"></span></span>.</p>
<p>In order to be able to have a ball-park comparison between our approach and the current status quo in decentralized application architecture, we proceed by modeling the worst-case time complexity both for a single node <span class="math inline"><em>Œ©</em><sub><em>S</em><em>y</em><em>s</em><em>t</em><em>e</em><em>m</em><em>N</em><em>o</em><em>d</em><em>e</em></sub></span> as well as for the whole system <span class="math inline"><em>Œ©</em><sub><em>S</em><em>y</em><em>s</em><em>t</em><em>e</em><em>m</em></sub></span> and both as functions of the number of state transitions (i.e. transactions) <span class="math inline"><em>n</em></span> and the number of nodes in the system <span class="math inline"><em>m</em></span>.</p>
## Bitcoin
<p>Let <span class="math inline"><em>Œ©</em><sub><em>B</em><em>i</em><em>t</em><em>c</em><em>o</em><em>i</em><em>n</em></sub></span> be the Bitcoin network, <span class="math inline"><em>n</em></span> be the number of transactions and <span class="math inline"><em>m</em></span> be the number full validating nodes (i.e. <em>miners</em><a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>) within <span class="math inline"><em>Œ©</em><sub><em>B</em><em>i</em><em>t</em><em>c</em><em>o</em><em>i</em><em>n</em></sub></span>.</p>
<p>For every new transaction being issued, any given node will have to check the transaction‚Äôs signature (among other checks, see. <span class="citation"></span>) and especially check if this transaction‚Äôs output is not used in any other transaction to reject double-spendings, resulting in a time complexity of <br /><span class="math display"><em>c</em>‚ÄÖ+‚ÄÖ<em>n</em></span><br /> per transaction. The time complexity in big-O notation per node as a function of the number of transactions is therefore <br /><span class="math display"><em>Œ©</em><sub><em>B</em><em>i</em><em>t</em><em>c</em><em>o</em><em>i</em><em>n</em><em>N</em><em>o</em><em>d</em><em>e</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(<em>n</em><sup>2</sup>).</span><br /> The complexity handled by one Bitcoin node does not <a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> depend on <span class="math inline"><em>m</em></span> the number of total nodes of the system. But since every node has to validate exactly the same set of transactions, the system‚Äôs time complexity as a function of number of transactions and number of nodes results as <br /><span class="math display"><em>Œ©</em><sub><em>B</em><em>i</em><em>t</em><em>c</em><em>o</em><em>i</em><em>n</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(<em>n</em><sup>2</sup><em>m</em>).</span><br /></p>
<p>Note that this quadratic time complexity of Bitcoin‚Äôs transaction validation process is what creates its main bottleneck as this reduces the network‚Äôs gossip bandwidth since every node has to validate every transaction before passing it along. In order to still have an average transaction at least flood through <span class="math inline">90%</span> of the network, block size and time can‚Äôt be pushed beyond 4MB and 12s respectively, according to <span class="citation"></span>.</p>
## Ethereum
<p>Let <span class="math inline"><em>Œ©</em><sub><em>E</em><em>t</em><em>h</em><em>e</em><em>r</em><em>e</em><em>u</em><em>m</em></sub></span> be the Ethereum main network, <span class="math inline"><em>n</em></span> be the number of transactions and <span class="math inline"><em>m</em></span> the number of full-clients within in the network.</p>
<p>The time complexity of processing a single transaction on a single node is a function of the code which‚Äôs execution is being triggered by the given transaction plus a constant: <br /><span class="math display"><em>c</em>‚ÄÖ+‚ÄÖ<em>f</em><sub><em>t</em><em>x</em><sub><em>i</em></sub></sub>(<em>n</em>,‚ÄÜ<em>m</em>).</span><br /> Similarly to Bitcoin and as a result of the Blockchain design decision to maintain one single state (<span class="math inline">$\forall n,m \in N: {\mathcal{X}}_n{\stackrel{!}{=}}{\mathcal{X}}_m$</span>, <em>‚ÄúThis is to be avoided at all costs as the uncertainty that would ensue would likely kill all confidence in the entire system.&quot;</em> <span class="citation"></span>), every node has to process every transaction being sent resulting in a time complexity per node as <br /><span class="math display">$$c+\sum_{i=0}^n f_{tx_i}(n,m)$$</span><br /> resulting in <br /><span class="math display"><em>Œ©</em><sub><em>E</em><em>t</em><em>h</em><em>e</em><em>r</em><em>e</em><em>u</em><em>m</em><em>N</em><em>o</em><em>d</em><em>e</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(<em>n</em>‚ÄÖ‚ãÖ‚ÄÖ<em>f</em><sub><em>t</em><em>x</em><sub><em>i</em></sub></sub>(<em>n</em>,‚ÄÜ<em>m</em>))</span><br /> whereas the complexity <span class="math inline"><em>f</em><sub><em>t</em><em>x</em><sub><em>i</em></sub></sub>(<em>n</em>,‚ÄÜ<em>m</em>)</span> of the code being run by Ethereum is typically held simple since execution has to be payed for in gas and is due to other restrictions such as the <em>block gas limit</em>. In other words, because of the complexity <span class="math inline"><em>f</em><sub><em>t</em><em>x</em><sub><em>i</em></sub></sub>(<em>n</em>,‚ÄÜ<em>m</em>)</span> being burdened upon all nodes of the system, other systemic properties have to keep users from running complex code on Ethereum so as to not bump into the limits of the network.</p>
<p>Again, since every node has to process the same set of all transactions, the time complexity of the whole system then is that of one node multiplied by <span class="math inline"><em>m</em></span>: <br /><span class="math display"><em>Œ©</em><sub><em>E</em><em>t</em><em>h</em><em>e</em><em>r</em><em>e</em><em>u</em><em>m</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(<em>n</em><em>m</em>‚ÄÖ‚ãÖ‚ÄÖ<em>f</em><sub><em>t</em><em>x</em><sub><em>i</em></sub></sub>(<em>n</em>,‚ÄÜ<em>m</em>)).</span><br /></p>
## Blockchain
<p>Both examples of Blockchain systems above do need a non-trivial computational overhead to work at all: the proof-of-work, hash-crack process also called <em>mining</em>. Since this overhead is not a function of either the number of transactions nor directly of the number of nodes, it is often omitted in complexity analysis. With the total energy consumption of all Bitcoin miners today being greater than the country of Iceland <span class="citation"></span>, neglecting the complexity of Blockchain‚Äôs consensus algorithm seems like a silly mistake.</p>
<p>Blockchains set the block time, the average time between two blocks, as a fixed parameter that the system keeps in homeostasis by adjusting the hash-crack‚Äôs difficulty according to the network‚Äôs total hash-rate. For a given network with a given set of mining nodes and a given total hash-rate, the complexity of the hash-crack is constant. But as the system grows and more miners come on-line, which increases the networks total hash-rate, the difficulty needs to increase in order to keep the average block time constant.</p>
<p>With this approach, the benefit of a higher total hash-rate is an increased difficulty of an adversary to influence the system by creating biased blocks (which renders this party able to do double-spend attacks). This is the sole rational behind this wasteful endeavor.</p>
<p>So, there is a direct relationship between the network‚Äôs total hash-rate and its level of security against mining power attacks. In order to formally discuss the complexity that needs to be added as an overhead to any Blockchain‚Äôs operation, we choose the free parameter to be the network‚Äôs total hash-rate <span class="math inline"><em>x</em><sub><em>H</em><em>R</em></sub></span> (in number of hashes per second) as an indicator for it‚Äôs level of security, i.e. the level of confidence any user can have in the integrity of the decentralized application implemented on-top of it and find that the complexity grows exponentially with the confidence of integrity. <br /><span class="math display"><em>Œ©</em><sub><em>B</em><em>l</em><em>o</em><em>c</em><em>k</em><em>c</em><em>h</em><em>a</em><em>i</em><em>n</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(2<sup><em>x</em><sub><em>H</em><em>R</em></sub></sup>)</span><br /></p>
## Holochain
<p>Let <span class="math inline"><em>Œ©</em><sub><em>H</em><em>C</em></sub></span> be a given Holochain system and let <span class="math inline"><em>n</em></span> be the sum of all public<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> (i.e. <em>put</em> to the DHT) state transitions (<em>transactions</em>) all agents in <span class="math inline"><em>Œ©</em><sub><em>H</em><em>C</em></sub></span> trigger in total and let <span class="math inline"><em>m</em></span> be the number of agents (= nodes) in the system.</p>
<p>Putting a new entry to the DHT involves finding a node that is responsible for holding that specific entry, which in our case according to <span class="citation"></span> has a time complexity of <br /><span class="math display"><em>c</em>‚ÄÖ+‚ÄÖ‚åà<em>l</em><em>o</em><em>g</em>(<em>m</em>)‚åâ.</span><br /> After receiving the state transition data, this node will gossip with its <span class="math inline"><em>q</em></span> neighbors which will result in <span class="math inline"><em>r</em></span> copies of this state transition entry being stored throughout the system - on <span class="math inline"><em>r</em></span> different nodes. Each of these nodes has to validate this entry which is an application specific logic of which the complexity we shall call <span class="math inline"><em>v</em>(<em>n</em>,‚ÄÜ<em>m</em>)</span>.</p>
<p>Combined, this results in a system-wide complexity per state transition as given with <br /><span class="math display">$$\underbrace{c+\lceil{log(m)}\rceil}_{DHT lookup}
+ q + r \cdot
\underbrace{v(n,m)}_{validation}$$</span><br /> which implies the following whole system complexity in <span class="math inline"><em>O</em></span>-notation <br /><span class="math display"><em>Œ©</em><sub><em>H</em><em>o</em><em>l</em><em>o</em><em>c</em><em>h</em><em>a</em><em>i</em><em>n</em></sub>‚ÄÑ‚àà‚ÄÑ<em>O</em>(<em>n</em>‚ÄÖ‚ãÖ‚ÄÖ(<em>l</em><em>o</em><em>g</em>(<em>m</em>)+<em>v</em>(<em>n</em>,‚ÄÜ<em>m</em>))</span><br /></p>
<p>Now, this is the overall system complexity. In order to enable comparison, we reason that in the case of Holochain without loss of generality (i.e. dependent on the specific Holochain application) the load of the whole system is shared equally by all nodes. Without further assumptions, for any given state transition the probability of it originating at a certain node is <span class="math inline">$\frac{1}{m}$</span>, so the term for the lookup complexity needs to be divided by <span class="math inline"><em>m</em></span> to describe the average lookup complexity per node. Other than in Blockchain systems where every node has to see every transaction, for the vast majority of state transitions one particular node is not involved at all. The stochastic closeness of the node‚Äôs public key‚Äôs hash with the entry‚Äôs hash is what triggers the node‚Äôs involvement. We assume the hash function <span class="math inline"><em>H</em></span> to show a uniform distribution of hash values which results in the probability of a certain node being one of the <span class="math inline"><em>r</em></span> nodes that cannot discard this entry to be <span class="math inline">$\frac{1}{m}$</span> times <span class="math inline"><em>r</em></span>. The average time complexity being handled by an average node then is <br /><span class="math display">$$\Omega_{HolochainNode} \in
O\left(\frac{n}{m}\cdot\left(log(m) + v(n,m)\right)\right).$$</span><br /> Note that the factor <span class="math inline">$\frac{n}{m}$</span> represents the average number of state transactions per node (i.e. the load per node) and that though this is a highly application specific value, it is an a priori expected lower bound since nodes have to process at least the state transitions they produce themselves.</p>
<p>The only overhead that is added by the architecture of this decentralized system is the node look-up with its complexity of <span class="math inline"><em>l</em><em>o</em><em>g</em>(<em>m</em>)</span>.</p>
<p>The unknown and also application specific complexity <span class="math inline"><em>v</em>(<em>n</em>,‚ÄÜ<em>m</em>)</span> of the validation routines is what could drive up the whole system‚Äôs complexity still. And indeed it is conceivable to think of Holochain applications with a lot of complexity within their validation routines. It is basically possible to mimic Blockchain‚Äôs consensus validation requirement by enforcing that a validating node communicates with all other nodes before adding an entry to the DHT. It could as well only be half of all nodes. And there surely is a host of applications with only little complexity - or specific state transitions within an application that involve only little complexity. <em>In a Holochain app one can put the complexity where it is needed and keep the rest of the system fast and scalable.</em></p>
<p>In the next chapter we proceed by providing real-world use cases and showing how non-trivial Holochain applications can be built that get along with <span class="math inline"><em>O</em>(<em>v</em>(<em>n</em>,‚ÄÜ<em>m</em>))‚ÄÑ=‚ÄÑ1</span>, resulting in a total time complexity per node in <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>m</em>))</span> and a high enough confidence in integrity index without introducing proof-of-work and its exponential complexity at all.</p>
# Use Cases
<p>Now we present a few use cases of applications built on Holochain, considering the context of the use case and how it affects both complexity and evaluation of integrity and thus validation design.</p>
## Social Media
<p>Consider a simple implementation of micro-blogging using Holochain where:</p>
<ol>
<li><p><span class="math inline"><em>F</em><sub><em>I</em></sub>‚ÄÑ=‚ÄÑ{<em>f</em><sub><em>p</em><em>o</em><em>s</em><em>t</em></sub>(<em>t</em><em>e</em><em>x</em><em>t</em>,‚ÄÜ<em>n</em><em>o</em><em>d</em><em>e</em>),<em>f</em><sub><em>f</em><em>o</em><em>l</em><em>l</em><em>o</em><em>w</em></sub>(<em>n</em><em>o</em><em>d</em><em>e</em>),<em>f</em><sub><em>r</em><em>e</em><em>a</em><em>d</em></sub>(<em>t</em><em>e</em><em>x</em><em>t</em>)}</span> and</p></li>
<li><p><span class="math inline"><em>F</em><sub><em>V</em></sub>‚ÄÑ=‚ÄÑ{<em>f</em><sub><em>i</em><em>s</em><em>O</em><em>r</em><em>i</em><em>g</em><em>i</em><em>n</em><em>a</em><em>t</em><em>o</em><em>r</em></sub>}</span></p></li>
</ol>
## Identity
## Money
<p>where the complexity of the transaction is higher, complexity may be <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> or <span class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em>(<em>n</em>))</span> see holo currency white paper: <span class="citation"></span></p>
# Implementation
<p>At the time of this writing we have a fully operational implementation of system as described in this paper, that includes two separate virtual machines for writing <span><span class="math inline">DNA</span></span>¬†functions in JavaScript, or Lisp, along with proof-of-concept implementations of a number of applications including a twitter clone, a slack-like chat system, DPKI, and a set mix-in libraries useful for building applications.</p>
<ol>
<li><p>30k+ lines of go code.</p></li>
<li><p>DHT: customized version of libp2p/ipfs‚Äôs kademlia implementation.</p></li>
<li><p>Network Transport: libp2p including end-to-end encryption.</p></li>
<li><p>Javascript Virtual Machine: otto<br />
<a href="https://github.com/robertkrimen/otto" class="uri">https://github.com/robertkrimen/otto</a></p></li>
<li><p>Lisp Virtual Machines: zygomys<br />
<a href="https://github.com/glycerine/zygomys" class="uri">https://github.com/glycerine/zygomys</a></p></li>
</ol>
# Appendix I: DHT<sub>hc</sub>
<ol>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>putLink</sub>(<em>b</em><em>a</em><em>s</em><em>e</em>,‚ÄÜ<em>l</em><em>i</em><em>n</em><em>k</em>,‚ÄÜ<em>t</em><em>a</em><em>g</em>)</span> where <span class="math inline"><em>b</em><em>a</em><em>s</em><em>e</em></span> and <span class="math inline"><em>l</em><em>i</em><em>n</em><em>k</em></span> are keys and where <span class="math inline"><em>t</em><em>a</em><em>g</em></span> is an arbitrary string, which associates the tuple {link,tag} with the key <span class="math inline"><em>b</em><em>a</em><em>s</em><em>e</em></span>.</p></li>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>getLinks</sub>(<em>b</em><em>a</em><em>s</em><em>e</em>,‚ÄÜ<em>t</em><em>a</em><em>g</em>)</span> where <span class="math inline"><em>b</em><em>a</em><em>s</em><em>e</em></span> is a key keys and where <span class="math inline"><em>t</em><em>a</em><em>g</em></span> is an arbitrary string, which returns the set of links on <span class="math inline"><em>b</em><em>a</em><em>s</em><em>e</em></span> identified by <span class="math inline"><em>t</em><em>a</em><em>g</em></span>.</p></li>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>mod</sub>(<em>k</em><em>e</em><em>y</em>,‚ÄÜ<em>n</em><em>e</em><em>w</em><em>k</em><em>e</em><em>y</em>)</span> where <span class="math inline"><em>k</em><em>e</em><em>y</em></span> and <span class="math inline"><em>n</em><em>e</em><em>w</em><em>k</em><em>e</em><em>y</em></span> are keys, which adds <span class="math inline"><em>n</em><em>e</em><em>w</em><em>k</em><em>e</em><em>y</em></span> as a modifier of <span class="math inline"><em>œÉ</em><sub>key</sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em></span> and calls <span class="math inline">$dht_\text{putLink}(key,newkey,replacedby&quot;)$</span></p></li>
<li><p><span class="math inline"><em>d</em><em>h</em><em>t</em><sub>del</sub>(<em>k</em><em>e</em><em>y</em>)</span> where <span class="math inline"><em>k</em><em>e</em><em>y</em></span> is a key, and marks <span class="math inline"><em>œÉ</em><sub>key</sub>‚ÄÑ‚àà‚ÄÑ<em>Œî</em></span> as deleted.</p></li>
<li></li>
</ol>
# Appendix II: F<sub>sys</sub>
<ol>
<li> </li>
</ol>
# Acknowledgements
<p>We thank Steve Sawin for his review of this paper, support and so much more...‚Ä¶</p>
### Lumber / Notes
<p>This is stuff that may or may not get used</p>
### Informal description
<p>All Holochain installations segment the computing space by application. Each application should be thought of as single distributed computing instance operating on a separate network from other applications. For each application, Holochain installations maintain separate nodes and state and communicate over separate isolated channels. Holochain applications can be connected, but only by external agents connecting one to another. This will be explained further in [sec:bridging]. Each node participating in a Holochain application maintains a hash-chain. The first entry in the chain of all nodes is identical, and we call the DNA. The DNA consists in the entry type definitions, executable source code, and property definitions, and most importantly validation rules that define that application. Nodes also participate in operating a distributed hash table together.</p>
<p>When external agents wish to initiate a transaction on a node they control, they call an ‚Äúexposed function&quot; which is subset of the executable source code that‚Äôs been defined as part of the application‚Äôs ‚ÄúAPI.&quot; These functions calls will result in changing state of the nodes only through adding one of the defined entry types to that node‚Äôs local chain. Adding data to a source chain has the side-effect of doing a DHT <span><code>put</code></span>operation for that entry, where the key is the same hash of the entry used for building the hash-chain. Thus entries are accessible to all other nodes on the network via a DHT <span><code>get</code></span>of that hash. However, all nodes receiving a <span><code>put</code></span>must first validate it by verify it with the source node.</p>
<p><span>9</span></p>

# Bibliography
<p>Quinn DuPont. <em>Experiments in Algorithmic Governance: A history and ethnography of ‚ÄúThe DAO,‚Äù a failed Decentralized Autonomous Organization</em><br />
<a href="http://www.iqdupont.com/assets/documents/DUPONT-2017-Preprint-Algorithmic-Governance.pdf" class="uri">http://www.iqdupont.com/assets/documents/DUPONT-2017-Preprint-Algorithmic-Governance.pdf</a></p>
<p>Gavin Wood. <em>Ethereum: A Secure Decentralised Generalised Transaction Ledger</em>.<br />
<a href="http://yellowpaper.io/" class="uri">http://yellowpaper.io/</a></p>
<p>Petar Maymounkov and David Mazieres <em>Kademlia: A Peer-to-peer Information System Base on the XOR Metric</em><br />
<a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf" class="uri">https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf</a></p>
<p>Zhang, H., Wen, Y., Xie, H., Yu, N. <em>Distributed Hash Table Theory, Platforms and Applications</em></p>
<p>Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin G√ºn Sirer, Dawn Song, Roger Wattenhofer, <em>On Scaling Blockchains</em>, Financial Cryptography and Data Security, Springer Verlag 2016</p>
<p>/u/mike_hearn, /u/awemany, /u/nullc et al.<br />
<a href="https://www.reddit.com/r/Bitcoin/comments/3a5f1v/mike_hearn_on_those_who_want_all_scaling_to_be/csa7exw/?context=3&amp;st=j8jfak3q&amp;sh=6e445294" class="uri">https://www.reddit.com/r/Bitcoin/comments/3a5f1v/mike_hearn_on_those_who_want_all_scaling_to_be/csa7exw/?context=3&amp;st=j8jfak3q&amp;sh=6e445294</a> Reddit discussion 2015</p>
<p>Marir, Toufik and Mokhati, Farid and Bouchelaghem-Seridi, Hassina and Tamrabet, Zouheyr&quot;, <em>Complexity Measurement of Multi-Agent Systems&quot;</em>, Multiagent System Technologies: 12th German Conference, MATES 2014, Stuttgart, Germany, September 23-25, 2014. Proceedings, Springer International Publishing 2014<br />
<a href="https://doi.org/10.1007/978-3-319-11584-9_13" class="uri">https://doi.org/10.1007/978-3-319-11584-9_13</a></p>
<p>Mark Coppock <em>THE WORLD‚ÄôS CRYPTOCURRENCY MINING USES MORE ELECTRICITY THAN ICELAND</em><br />
<a href="https://www.digitaltrends.com/computing/bitcoin-ethereum-mining-use-significant-electrical-power/" class="uri">https://www.digitaltrends.com/computing/bitcoin-ethereum-mining-use-significant-electrical-power/</a></p>
<p><em>Bitcoin Protocol</em><br />
<a href="https://en.bitcoin.it/wiki/Protocol_rules#.22tx.22_messages" class="uri">https://en.bitcoin.it/wiki/Protocol_rules#.22tx.22_messages</a> Bitcoin Wiki</p>
<p>Juan Benet <em>IPFS - Content Addressed, Versioned, P2P File System (DRAFT 3)</em><br />
<a href="https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf" class="uri">https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf</a></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>https://git-scm.com/about<a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>https://bitcoin.org/bitcoin.pdf<a href="#fnref2">‚Ü©</a></p></li>
<li id="fn3"><p>add various sources<a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p>more footnotes here<a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p>pointer here<a href="#fnref5">‚Ü©</a></p></li>
<li id="fn6"><p>https://github.com/ethereum/wiki/wiki/White-Paper<a href="#fnref6">‚Ü©</a></p></li>
<li id="fn7"><p>link to that article<a href="#fnref7">‚Ü©</a></p></li>
<li id="fn8"><p>anther link<a href="#fnref8">‚Ü©</a></p></li>
<li id="fn9"><p>For the sake of simplicity and focusing on a lower bound of the system‚Äôs complexity, we are neglecting all nodes that are not crucial for the operation of the network, such as light-clients and clients not involved in the process of validation<a href="#fnref9">‚Ü©</a></p></li>
<li id="fn10"><p>not inherently - that is more participants will result in more transactions but we model both values as separate parameters<a href="#fnref10">‚Ü©</a></p></li>
<li id="fn11"><p>private (see:[private]) state transitions, i.e. that are confined to a local <span class="math inline">ùí≥<sub><em>n</em></sub></span>, are completely within the scope of a node‚Äôs agency and don‚Äôt affect other parts of the system directly and can therefore be omitted for the complexity analysis of <span class="math inline"><em>Œ©</em><sub><em>H</em><em>C</em></sub></span> as a distributed system<a href="#fnref11">‚Ü©</a></p></li>
</ol>
</div>
